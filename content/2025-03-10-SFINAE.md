---
title: C++/SFINAE
draft: false
tags:
  - C++
---

SFINAE（Subsitution Failure Is Not An Error），该原则是指当模板参数替换失败时，编译器不会报错，而是继续查找其他可能匹配的重载函数或模板特化。

该方法主要的作用有以下：
1. 实现函数重载的条件选择
2. 实现编译器类型特征检测
3. 启用/禁用特定模板实例化

以下是一个比较实际的例子，假设我们有以下代码
```cpp
switch(token)
{
case IDENTIFIER:
    // do something
    break;
case LITERAL_NUMBER:
    // do something
    break;
case LITERAL_STRING:
    // do something
    break;
default:
    throw WrongToken(token);
}
```
如果token是LITERAL_NUMBER时，那么第一步会去匹配IDENTIFIE，显然这是不匹配的，于是可以认为是**failure**。

如果token不是IDENTIFIER/LITERAL_NUMBER/LITERAL_STRING任意一个时，于是可以认为是**error**。

因此可以得知，failure并不是error，只有所有情况都是failure，那么才是error。

以上解释了SFINAE中的failure和error，那么现在需要引入Subsituition，于是引入以下三个定义
1. 什么时候函数模板发生Subsitution
2. 什么行为被称为Subsituition
3. 什么行为不是Subsitution failure，而是Subsitution error

# 非良构
在C++中，非良构指的是**代码不符合C++标准语法或语义规则的情况**。

具体有大致以下几种情况
1. 语法错误
2. 模板元编程中的替换失败，根据**SFINAE**原则，编译器会跳过该模板，但若所有候选模板均失败则报错
3. C++11后引入的[[attribute]]如果使用的场景不符合属性的定义，如以下代码中[[fallthrough]]指的是故意不break，而是流转到下一个case，显然最后一个选项无法流转，因此是非良构的
```cpp
void f() {
    switch(n) {
        case 1: [[fallthrough]];  // 正确：允许直落
        case 2: break;
        case 3: [[fallthrough]];  // 非良构：下一语句非 case 标号[6](@ref)
    }
}
```
4. 异常规范冲突
```cpp
struct Base { virtual void f() noexcept; };
struct Derived : Base { void f(); }; 
```
这样写居然是错误的...由于子类的异常规范（exception specification）不能比基类宽松，因此这里会报错

5. 值或类型不匹配，例如以下，显然会报错
```cpp
int a = "114514";
```

# std::enable_if
std::enable_if是一个基于SFINAE的模板元编程工具，用于在编译时根据条件控制模板的实例化。

具体使用方法为，对于`std::enable_if<bool B, class T = void>`，如果B为true，则该std::enable_if拥有T的type，具体调用方法为`using enable_if_t = typename enable_if<B,T>::type`。

有了这个工具，可以用于解决模板中函数重载的问题，我理解类似使用了std::enable_if当作一个哑元，解决了参数相同的冲突，同时结合了SFINAE的匹配规则，使得模板能匹配到正确的参数。

以下是一个提到的例子
```cpp
struct ICounter {
  virtual void increase() = 0;
  virtual ~ICounter() {}
};

struct Counter: public ICounter {
   void increase() override {
      // Implements
   }
};

template <typename T>
void inc_counter(T& counterObj) {
  counterObj.increase();
}

template <typename T>
void inc_counter(T& intTypeCounter){
  ++intTypeCounter;
}

void doSomething() {
  Counter cntObj;
  uint32_t cntUI32;

  // blah blah blah
  inc_counter(cntObj);
  inc_counter(cntUI32);
}
```

显然这样编译错误，在编译器的视角，定义的两个inc_counter的函数签名是一样的，于是可以使用std::enable_if去解决这个问题。

```cpp
template <typename T> void inc_counter(
  T& counterObj, 
  typename std::enable_if<
    std::is_base_of<T, ICounter>::value
  >::type* = nullptr );

template <typename T> void inc_counter(
  T& counterInt,
  typename std::enable_if<
    std::is_integral<T>::value
  >::type* = nullptr );
```

对于这两个函数，分别使用了std::is_base_of和std::is_integral
- std::is_base_of：std::is_base_of<T, ICounter>::value是一个bool类型，返回值表示T是否是ICounter的子类
- std::is_integral：std::is_integral\<T\>::value表示T是否是一个整形类型

通过这两个std::enable_if，可以区分开上文中两种调用方法，显然它们各自会匹配以下两个中的一个规则，匹配另一个规则时，由于不满足std::enable_if的条件，则无法实例化，于是根据SFINAE规则继续匹配其他实例化函数的方法。




---
来源：
[C++模板进阶指南：SFINAE](https://zhuanlan.zhihu.com/p/21314708)