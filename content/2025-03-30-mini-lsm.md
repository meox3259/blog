---
title: Mini-LSM
tags:
  - rust
  - 分布式存储
  - rocksdb
---

# Compaction

Mini-Lsm中实现了三种Compaction的流程，

## 流程

Compaction实现是通过一个后台线程进行定期Compaction，每50ms执行一次
```rust
let handle = std::thread::spawn(move || {
  let ticker = crossbeam_channel::tick(Duration::from_millis(50));
  loop {
    crossbeam_channel::select! {
      recv(ticker) -> _ => if let Err(e) = this.trigger_compaction() {
        eprintln!("compaction failed: {}", e);
      },
      recv(rx) -> _ => return
    }
  }
});
```

**trigget compaction**

单次Compaction调用trigget_compaction开始执行，里面函数调用大概如下：
- `let task = self.compaction_controller.generate_compaction_task(&snapshot)`：检测当前lsm tree的结构查看是否需要进行Compaction，如果需要调用，则生成一个task，task里包含了所有需要合并的level和sst；compaction_controller封装了3种不同的compaction策略
- `let sstables = self.compact(&task)?`：根据task种sst的信息，将这些sst进行合并。具体合并的流程为，首先把所有sst包装成一个iterator，具体iterator的类型根据不同的策略产生，iterator的目的是将这些sst的数据进行排序。把iterator中排好序的数据不断取出，然后生成一些排好序的sst
- 更新sst：目前获取了需要被合并的sst，以及新生成的sst，那么把被合并的sst删除，然后把新的sst插入对应的位置。不同策略插入的方法单独实现

## 策略

### Simple Compaction Strategy
最简单的策略，枚举相邻两层i和i+1，查看相邻两层的文件数量比值，如果比值大于了阈值，那么将这两层中全部sst进行compaction，然后插入i+1层

### Tiered Compaction Strategy
这种策略会跳过l0层，每次将一个imm刷入ssd中成为sst时，在所有level之前插入一个新的level，只包含当前最新的sst，对应的合并策略一共有三种：
1. 从上到下枚举，计算$[0,max_level-1]$层的sst数和$level$层的$sst$数量的比值，如果大于一个阈值则将lsm tree中所有sst合并成一个层，lsm tree的层数也会变成1
2. 从上到下枚举，计算$[0,i]$层的sst数和$i+1$层的$sst$数量的比值，如果大于一个阈值则将$[0,i]$所有sst合并
3. 当以上两种策略都失效时，将前max_merge_width层的sst进行合并

注意当总层数小于num_tier时，不进行compaction，防止过于频繁地compaction。

### Leveled Compaction Strategy
由于上两种方法总是会将若干层中所有sst都进行合并，这样写放大过于严重，于是leveled compaction strategy如果不是合并l0时一次只选择一个sst进行compaction。

同样以上策略还存在一个问题，即如果lsm tree已经将所有sst都合并到了底部，那么中间的层都是空的，这样如果保留这些层，那么显然一个新刷新的imm需要额外合并很多次才能到最底层，显然是浪费的。因此这里求出一个最靠上非空的位置base_level，当l0层sst进行compaction时，直接和base_level进行合并。

然后考虑非l0层的compaction。采用的策略是对于第i层计算一个预估的大小$target_i$，当前大小为$real_i$。如果超过了这个大小则计算该层超出的比例$ratio=\frac{real_i}{target_i}$，然后选择$ratio$最大的层进行合并到下一层。首先会预设一个base_level_size，表示最底层的sst大小，以及一个层之间的放大倍数multiply，即i+1层应该是i层的multiply倍。最后一层预估的大小为预估和现实大小的较大值，然后根据multiply系数计算出每层预估大小。